/**
 * Property Opportunity Generator — Procedural real estate deals
 *
 * Generates dynamic property opportunities with randomized attributes
 * and a location grade.  Opportunities persist until the next periodic
 * refresh.  Once purchased, they become permanent properties.
 *
 * Districts have been replaced by a lightweight LocationGrade system.
 */
import { D } from '@renderer/core/BigNum'
import type Decimal from 'break_infinity.js'
import { type PropertyCategory, type LocationGrade, rollLocationGrade, getLocationGrade } from './locations'
import { PROPERTY_TEMPLATES, type PropertyTemplate } from './templates'
import { PROPERTY_TRAITS, type PropertyTrait } from './customizations'

// ═══════════════════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════════════════

export const OPPORTUNITY_REFRESH_TICKS = 90_000
export const MIN_OPPORTUNITIES = 2
export const MAX_OPPORTUNITIES = 5

export type ScoutPhase = 'none' | 'drive_by' | 'inspection' | 'appraisal'
export const SCOUT_PHASES: ScoutPhase[] = ['none', 'drive_by', 'inspection', 'appraisal']

export interface ScoutPhaseData {
  id: ScoutPhase
  nameKey: string
  icon: string
  costMultiplier: number
  revealsKey: string
}

export const SCOUT_PHASE_DATA: Record<ScoutPhase, ScoutPhaseData> = {
  none: { id: 'none', nameKey: 'realestate.scout.none', icon: 'mdi:help-circle-outline', costMultiplier: 0, revealsKey: '' },
  drive_by: { id: 'drive_by', nameKey: 'realestate.scout.drive_by', icon: 'mdi:car', costMultiplier: 0.05, revealsKey: 'realestate.scout.drive_by_reveals' },
  inspection: { id: 'inspection', nameKey: 'realestate.scout.inspection', icon: 'mdi:magnify', costMultiplier: 0.12, revealsKey: 'realestate.scout.inspection_reveals' },
  appraisal: { id: 'appraisal', nameKey: 'realestate.scout.appraisal', icon: 'mdi:file-document-check', costMultiplier: 0.25, revealsKey: 'realestate.scout.appraisal_reveals' },
}

export const APPRAISAL_DISCOUNT = 0.03

/** Cost to Scout the Market (scales with net worth).  Replaces per-district scan. */
export function getScoutMarketCost(netWorth: number): number {
  // Starts at $500, scales gently:  500 + 0.1% of net worth, capped at $5M
  return Math.min(5_000_000, Math.round(500 + netWorth * 0.001))
}

/** Scout the Market cooldown: 5 min real-time */
export const SCOUT_COOLDOWN_MS = 5 * 60 * 1000

// ═══════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════

export interface PropertyOpportunity {
  id: string
  templateId: string
  name: string
  icon: string
  category: PropertyCategory
  locationGrade: LocationGrade

  askingPrice: Decimal
  trueValue: Decimal
  baseRent: Decimal
  units: number

  startingCondition: number
  wearRate: number
  taxRate: number
  baseAppreciationRate: number
  baseMaintenance: Decimal
  maxRenovationLevel: number
  renovationCostMultiplier: number

  traits: PropertyTrait[]

  scoutPhase: ScoutPhase
  scoutCosts: Record<ScoutPhase, number>

  appearedAt: number
  isHotDeal: boolean
  /** Whether this opportunity was found via market scout */
  isScanned: boolean
}

// ═══════════════════════════════════════════════════════════════════
// GENERATORS
// ═══════════════════════════════════════════════════════════════════

function rand(min: number, max: number): number {
  return min + Math.random() * (max - min)
}

function pick<T>(arr: T[]): T {
  return arr[Math.floor(Math.random() * arr.length)]
}

function pickN<T>(arr: T[], n: number): T[] {
  const shuffled = [...arr].sort(() => Math.random() - 0.5)
  return shuffled.slice(0, Math.min(n, arr.length))
}

/** Street-style procedural name */
function generateName(template: PropertyTemplate): string {
  const suffixes = [
    `#${Math.floor(Math.random() * 999) + 1}`,
    ['North', 'South', 'East', 'West'][Math.floor(Math.random() * 4)],
    `${Math.floor(Math.random() * 200) + 1} ${['St', 'Ave', 'Blvd', 'Rd'][Math.floor(Math.random() * 4)]}`,
    ['Park', 'Hill', 'Heights', 'Bay', 'View', 'Lake'][Math.floor(Math.random() * 6)],
  ]
  return `${template.name} — ${pick(suffixes)}`
}

/**
 * Generate a single property opportunity.
 *
 * @param netWorth – Player's current net worth
 * @param currentTime – Date.now() for unique IDs
 * @param isScanned – true if generated by "Scout Market"
 * @param forceGrade – override random grade (for scout bonuses)
 */
export function generateOpportunity(
  netWorth: number,
  currentTime: number,
  isScanned = false,
  forceGrade?: LocationGrade,
): PropertyOpportunity {
  // 1. Grade
  const grade = forceGrade ?? rollLocationGrade(netWorth)
  const gradeData = getLocationGrade(grade)

  // 2. Template (pick one the player can afford)
  const eligible = PROPERTY_TEMPLATES.filter((t) => netWorth >= t.minNetWorth)
  const template = eligible.length > 0 ? pick(eligible) : PROPERTY_TEMPLATES[0]
  const category = pick(template.categories)

  // 3. Price (light net-worth scaling so late-game sees slightly pricier deals)
  const netWorthFactor = Math.max(1, Math.log10(Math.max(netWorth, 1000)))
  const priceBase = rand(template.priceRange[0], template.priceRange[1])
  const scaledPrice = priceBase * (1 + (netWorthFactor - 3) * 0.15)
  const askingPrice = D(Math.round(scaledPrice))

  const valueVariance = rand(0.85, 1.15)
  const trueValue = D(Math.round(scaledPrice * valueVariance))

  // 4. Rent — grade multiplier is baked into baseRent here (single source of truth)
  const baseRentNum = rand(template.baseRentRange[0], template.baseRentRange[1])
  const baseRent = D(Math.round(baseRentNum * gradeData.rentMultiplier * 100) / 100)

  // 5. Units
  const units = template.unitRange[0]
    + Math.floor(Math.random() * (template.unitRange[1] - template.unitRange[0] + 1))

  // 6. Condition
  const startingCondition = Math.round(rand(template.conditionRange[0], template.conditionRange[1]))

  // 7. Traits
  const traitCount = Math.floor(rand(1, 3.5))
  const traits = pickN(PROPERTY_TRAITS, traitCount)

  // 8. Hot deal
  const isHotDeal = Math.random() < 0.15

  // 9. Scout costs
  const priceNum = askingPrice.toNumber()
  const scoutCosts: Record<ScoutPhase, number> = {
    none: 0,
    drive_by: Math.round(priceNum * SCOUT_PHASE_DATA.drive_by.costMultiplier),
    inspection: Math.round(priceNum * SCOUT_PHASE_DATA.inspection.costMultiplier),
    appraisal: Math.round(priceNum * SCOUT_PHASE_DATA.appraisal.costMultiplier),
  }

  return {
    id: `prop_opp_${currentTime}_${Math.random().toString(36).slice(2, 8)}`,
    templateId: template.id,
    name: generateName(template),
    icon: template.icon,
    category,
    locationGrade: grade,
    askingPrice: isHotDeal ? D(Math.round(askingPrice.toNumber() * 0.9)) : askingPrice,
    trueValue,
    baseRent,
    units,
    startingCondition,
    wearRate: rand(template.wearRateRange[0], template.wearRateRange[1]),
    taxRate: rand(template.taxRateRange[0], template.taxRateRange[1]),
    baseAppreciationRate: template.baseAppreciationRate * gradeData.appreciationMultiplier,
    baseMaintenance: D(Math.round(baseRentNum * template.maintenanceRatio * 100) / 100),
    maxRenovationLevel: template.maxRenovationLevel,
    renovationCostMultiplier: template.renovationCostMultiplier,
    traits,
    scoutPhase: 'none',
    scoutCosts,
    appearedAt: currentTime,
    isHotDeal,
    isScanned,
  }
}

/**
 * Generate premium opportunities from "Scout Market" action.
 * Better quality: biased toward higher grades, positive traits, slight value bump.
 */
export function generateScoutOpportunity(
  netWorth: number,
  currentTime: number,
): PropertyOpportunity {
  // Bias grade upward by rolling twice and keeping the better one
  const g1 = rollLocationGrade(netWorth)
  const g2 = rollLocationGrade(netWorth)
  const gradeOrder: LocationGrade[] = ['D', 'C', 'B', 'A', 'S']
  const grade = gradeOrder.indexOf(g1) >= gradeOrder.indexOf(g2) ? g1 : g2

  const opp = generateOpportunity(netWorth, currentTime, true, grade)
  // Scanned opportunities have slightly higher true value (better deal)
  opp.trueValue = D(Math.round(opp.trueValue.toNumber() * rand(1.05, 1.2)))
  // Bias traits toward positive
  if (opp.traits.length > 0 && opp.traits.every((t) => !t.isPositive)) {
    const positiveTraits = PROPERTY_TRAITS.filter((t) => t.isPositive)
    opp.traits[0] = pick(positiveTraits)
  }
  return opp
}

/**
 * Generate a batch of opportunities.
 */
export function generateOpportunityBatch(
  netWorth: number,
  currentTime: number,
  count: number,
): PropertyOpportunity[] {
  const opps: PropertyOpportunity[] = []
  for (let i = 0; i < count; i++) {
    opps.push(generateOpportunity(netWorth, currentTime))
  }
  return opps
}
